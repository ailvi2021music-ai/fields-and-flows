<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <title>Поля и Потоки</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #05070d;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont;
    }
    canvas { display:block; }

    .mode-toggle {
      position: fixed;
      top: 14px;
      right: 14px;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.12);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: all .3s ease;
      user-select: none;
    }
    .mode-toggle.light {
      background: rgba(0,0,0,0.06);
      color: #111;
      border: 1px solid rgba(0,0,0,0.10);
    }
  </style>
</head>
<body>

<canvas id="field"></canvas>
<div class="mode-toggle" id="modeToggle" title="Переключить состояние">◐</div>

<script>
/* =========================================================
   v0.2.1 — FIX: ядра/потоки снова видны + дневной режим читается
========================================================= */

const canvas = document.getElementById("field");
const ctx = canvas.getContext("2d");

let w, h, cx, cy, DPR;

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function rand(min, max){ return min + Math.random() * (max - min); }

/* ===========================
   РЕЖИМ
=========================== */

let mode = "deep"; // deep | focus
const toggle = document.getElementById("modeToggle");
toggle.onclick = () => {
  mode = mode === "deep" ? "focus" : "deep";
  toggle.classList.toggle("light", mode === "focus");
};

/* ===========================
   ЯДРА
=========================== */

const cores = [
  { x: 0, y: 0, r: 26, phase: Math.random()*10 },
  { x: 0, y: 0, r: 22, phase: Math.random()*10 },
  { x: 0, y: 0, r: 28, phase: Math.random()*10 },
  { x: 0, y: 0, r: 20, phase: Math.random()*10 },
];

function placeCores(){
  // размещение относительно центра (после resize!)
  cores[0].x = cx - 220; cores[0].y = cy - 80;
  cores[1].x = cx + 180; cores[1].y = cy - 120;
  cores[2].x = cx + 120; cores[2].y = cy + 140;
  cores[3].x = cx - 160; cores[3].y = cy + 160;
}

/* ===========================
   ПОТОКИ
=========================== */

const flows = [
  [0,1],
  [1,2],
  [2,3],
  [3,0]
];

/* ===========================
   ФОН: ЧАСТИЦЫ
=========================== */

let particlesFar = [];
let particlesNear = [];

function makeParticle(layer) {
  const isFar = layer === "far";
  const baseSize = isFar ? rand(0.4, 1.2) : rand(0.8, 2.2);

  return {
    x: rand(0, w),
    y: rand(0, h),

    vx: isFar ? rand(-0.06, 0.06) : rand(-0.14, 0.14),
    vy: isFar ? rand(-0.04, 0.04) : rand(-0.10, 0.10),

    z: rand(0.2, 1.0),
    vz: isFar ? rand(-0.0006, 0.0006) : rand(-0.0012, 0.0012),

    tw: rand(0, Math.PI*2),
    twSpeed: isFar ? rand(0.008, 0.02) : rand(0.012, 0.03),

    size: baseSize,
    baseAlpha: isFar ? rand(0.10, 0.32) : rand(0.10, 0.26),

    sparkle: Math.random() < (isFar ? 0.05 : 0.03),
    sparkleT: rand(0, 9999),
  };
}

function initParticles() {
  const farCount  = Math.round((w*h) / 45000);
  const nearCount = Math.round((w*h) / 28000);

  particlesFar  = Array.from({length: Math.min(120, Math.max(18, farCount))},  () => makeParticle("far"));
  particlesNear = Array.from({length: Math.min(180, Math.max(28, nearCount))}, () => makeParticle("near"));
}

/* ===========================
   RESIZE (ВАЖНО!)
=========================== */

function resize() {
  DPR = clamp(window.devicePixelRatio || 1, 1, 2); // производительность
  w = Math.floor(window.innerWidth);
  h = Math.floor(window.innerHeight);

  canvas.width  = Math.floor(w * DPR);
  canvas.height = Math.floor(h * DPR);
  canvas.style.width = w + "px";
  canvas.style.height = h + "px";

  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  cx = w / 2;
  cy = h / 2;

  placeCores();     // FIX: ставим ядра после расчёта cx/cy
  initParticles();  // пересоздаём фон под новый размер
}
window.addEventListener("resize", resize);

/* ===========================
   РЕНДЕР
=========================== */

let t = 0;

function drawBackground() {
  const breathe = (Math.sin(t * 0.01) + 1) * 0.5;

  const grd = ctx.createRadialGradient(
    cx + (mode === "deep" ? (breathe - 0.5) * 30 : (breathe - 0.5) * 18),
    cy + (mode === "deep" ? (0.5 - breathe) * 24 : (0.5 - breathe) * 14),
    120,
    cx, cy,
    Math.max(w, h)
  );

  if (mode === "deep") {
    grd.addColorStop(0, "#0b1022");
    grd.addColorStop(0.55, "#040611");
    grd.addColorStop(1, "#02030a");
  } else {
    grd.addColorStop(0, "#f6f8ff");
    grd.addColorStop(0.65, "#e8edff");
    grd.addColorStop(1, "#dde4ff");
  }

  ctx.fillStyle = grd;
  ctx.fillRect(0,0,w,h);

  if (mode === "deep") {
    ctx.fillStyle = "rgba(10,14,28,0.10)";
    ctx.fillRect(0,0,w,h);
  } else {
    // лёгкая “вуаль”, чтобы белый не был пустым
    ctx.fillStyle = "rgba(255,255,255,0.35)";
    ctx.fillRect(0,0,w,h);
  }
}

function updateAndDrawParticles(list, layer) {
  const isFar = layer === "far";

  // делаем частицы ВИДИМЫМИ и в focus
  const alphaMul = (mode === "deep")
    ? (isFar ? 1.0 : 0.95)
    : (isFar ? 0.85 : 0.70);

  const speedMul = (mode === "deep") ? 1.0 : 1.12;

  for (const p of list) {
    p.x += p.vx * speedMul * (0.6 + p.z);
    p.y += p.vy * speedMul * (0.6 + p.z);

    p.z += p.vz;
    if (p.z < 0.15 || p.z > 1.15) p.vz *= -1;

    if (p.x < -20) p.x = w + 20;
    if (p.x > w + 20) p.x = -20;
    if (p.y < -20) p.y = h + 20;
    if (p.y > h + 20) p.y = -20;

    p.tw += p.twSpeed;
    const twinkle = 0.65 + 0.35 * Math.sin(p.tw);

    let spark = 0;
    if (mode === "deep" && p.sparkle) {
      p.sparkleT += 1;
      if ((p.sparkleT % Math.floor(320 + Math.random()*520)) === 0) p.sparkleT = 1;
      if (p.sparkleT > 0 && p.sparkleT < 25) spark = (25 - p.sparkleT) / 25;
      if (p.sparkleT >= 25) p.sparkleT = 0;
    }

    let r,g,b;
    if (mode === "deep") {
      r = 170; g = 200; b = 255; // холодные искры
    } else {
      r = 115; g = 130; b = 185; // дневная “пыль” (чётко на светлом)
    }

    const a = Math.min(0.65,
      (p.baseAlpha * alphaMul) * twinkle + spark * (isFar ? 0.22 : 0.16)
    );

    const s = p.size * (0.75 + p.z * 0.8) * (mode === "deep" ? 1.0 : 0.95);

    ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, s, 0, Math.PI*2);
    ctx.fill();

    if (mode === "deep" && !isFar) {
      ctx.fillStyle = `rgba(${r},${g},${b},${a * 0.18})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, s*3.0, 0, Math.PI*2);
      ctx.fill();
    }

    if (mode === "focus" && !isFar) {
      // на светлом — мягкая “дымка” вокруг, очень тонко
      ctx.fillStyle = `rgba(${r},${g},${b},${a * 0.10})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, s*3.2, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

function drawFlows() {
  ctx.lineWidth = mode === "deep" ? 1.2 : 1.8;
  ctx.strokeStyle = mode === "deep"
    ? "rgba(140,180,255,0.26)"
    : "rgba(70,90,165,0.42)"; // усилено для светлого

  flows.forEach(([a,b], i) => {
    const A = cores[a];
    const B = cores[b];
    const sway = Math.sin(t*0.02 + i)*20 + Math.sin(t*0.006 + i*2.1)*10;

    ctx.beginPath();
    ctx.moveTo(A.x, A.y);
    ctx.quadraticCurveTo(
      (A.x + B.x)/2 + sway,
      (A.y + B.y)/2 - sway,
      B.x, B.y
    );
    ctx.stroke();
  });
}

function drawCores() {
  for (const c of cores) {
    c.phase += (mode === "deep" ? 0.010 : 0.014);
    const pulse = Math.sin(c.phase) * (mode === "deep" ? 2.2 : 1.6);

    const fill = (mode === "deep")
      ? "rgba(120,160,255,0.88)"
      : "rgba(55,75,155,0.96)"; // усилено

    // сфера
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r + pulse, 0, Math.PI*2);
    ctx.fillStyle = fill;
    ctx.shadowColor = fill;
    ctx.shadowBlur = (mode === "deep" ? 22 : 16);
    ctx.fill();
    ctx.shadowBlur = 0;

    // аура
    ctx.strokeStyle = (mode === "deep")
      ? "rgba(180,210,255,0.22)"
      : "rgba(55,75,155,0.24)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r + pulse + (mode === "deep" ? 10 : 9), 0, Math.PI*2);
    ctx.stroke();
  }
}

function animate() {
  t++;

  drawBackground();
  updateAndDrawParticles(particlesFar, "far");
  updateAndDrawParticles(particlesNear, "near");
  drawFlows();
  drawCores();

  requestAnimationFrame(animate);
}

/* старт */
resize();
animate();
</script>
</body>
</html>
